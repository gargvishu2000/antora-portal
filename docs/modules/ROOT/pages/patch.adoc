= Portal Patch process
Active Intelligence Platform
:title-logo-image: image:/theme/logo.png[pdfwidth=3.5in,align=right]
:revnumber: v0.1.1
:doctype: book
:encoding: utf-8
:lang: en
:numbered:
:icons: font
:source-highlighter: rouge
:sectnumlevels: 5
:toc: left
:chapter-label:


== Introduction

This document details all portal patch processes.

=== Naming Conventions

In this document the following naming conventions will be established.

|===
|Variable | Meaning/mapping

|${YOUR_NAMESPACE} | The kubernetes namespace where to deploy all the elements of the installation
|${UPGRADE_CHART_VERSION} | The chart version to be used when upgrading the deployment
|${UPGRADE_IMAGE_REG} | The new image registry to be used when upgrading the deployment
|${UPGRADE_IMAGE_REPO} | The new image repository to be used when upgrading the deployment
|${UPGRADE_IMAGE_TAG} | The new image tag to be used when upgrading the deployment
|${LIST_OF PATCHES} | Directory containing a list of patches to be applied.

|===

== Types of Patches

The patch process can be *divided* into *two* different pipelines:

* *Patches applied with helm upgrade:* you only need to execute `helm upgrade` command.
* *Patches that require launching a job*: requires a storage patch location, under the deployment directory, and that can be set using the `deployment.patch-path` option.

Next you can consult a list with the different patch scenarios and which category they belong to.

=== Patches applied with helm upgrade only

* *Patches to AIP Image:* when there are structural changes to the portal image.
* *Filesystem patches:* to apply filesystem patches on pod startup.
* *Cumulative patches:* cumulative patches with no database changes.

=== Patches that require launching a job

* *Database patches*
* *SPO patches*
* *JavaScript patches*

== Applying patches

The next steps will use xref:install.adoc#_install_portal_eg[this] as base for the different patch scenarios.

=== Applying patch to AIP Image

When there are *structural changes* to the portal image you can apply a patch by upgrading the release itself, running the following command:

[source,bash]
----
helm upgrade portal \
  --set deployment.upgrade-path=upgrade \
  --set image.registry=${UPGRADE_IMAGE_REG} \
  --set image.repository=${UPGRADE_IMAGE_REPO} \
  --set image.tag=${UPGRADE_IMAGE_TAG} \
  --timeout 30m \
  <PATH_TO_BUNDLE>/charts/ \
  --version "${UPGRADE_CHART_VERSION}"
----

=== Applying Filesystem patches

Filesystem patches run on pod startup.

To get started, place all patches under `patches` of your deployment `startup` directory. Then restart your deployment by executing the following command:

[source,bash]
----
kubectl scale deployment portal --replicas=0 && \
kubectl scale deployment portal --replicas=1
----

=== Applying cumulative patches

Cumulative patches - with *no database changes* - are applied the same way as patching the AIP image, meaning a `helm upgrade` command:

[source,bash]
----
helm upgrade portal \
  --set deployment.upgrade-path=upgrade \
  --set image.registry=${UPGRADE_IMAGE_REG} \
  --set image.repository=${UPGRADE_IMAGE_REPO} \
  --set image.tag=${UPGRADE_IMAGE_TAG} \
  --timeout 30m \
  <PATH_TO_BUNDLE>/charts/ \
  --version "${UPGRADE_CHART_VERSION}"
----

=== Applying SPO, Database and JavaScript patches

SPO, Database and JavaScript patches, all require a job to perform the patch process.

==== Upload the process

==== Upload patches

All patches should be placed under `patches` of your deployment `patch` directory.

[source,shell]
----
aws s3 cp ${LIST_OF PATCHES}/ s3://mybucket/example/portal/patch/patches/
----

==== Apply the patches

Launch the *patch process*, running the following command:

[source,bash]
----
helm upgrade portal \
  --set deployment.patch-path=patch \
  --set image.registry=${UPGRADE_IMAGE_REG} \
  --set image.repository=${UPGRADE_IMAGE_REPO} \
  --set image.tag=${UPGRADE_IMAGE_TAG} \
  --timeout 30m \
  <PATH_TO_BUNDLE>/charts/ \
  --version "${UPGRADE_CHART_VERSION}"
----

==== Restart deployment

Then restart your deployment, to get the new configurations and receive new WAR files, by executing the following command:

[source,bash]
----
kubectl scale deployment portal --replicas=0 && \
kubectl scale deployment portal --replicas=1
----